import array
import sys
import math

"""
Method 2
Using alpha beta test, we assign the MINMAX number to the states generated by the open positions
Considering the values a for MAX (number of lines along the X having no other pebble) and b for MIN (number of lines in the state having any pebble)

Let MINMAX value = a - b

For the safest move, the state having the single highest MINMAX value is chosen

If a single highest state is not found, consider the state with the highest a and lowest b

If in the previous step we obtain the states having the same a and b values, choose the first state

"""
#uncomment below three lines when ready to work with command line
n = int(sys.argv[1])
inputStr = sys.argv[2]
t = int(sys.argv[3])

#comment below three lines when ready to work with command line
#n = 4
itemCount = n * n
#inputStr = ".x.x...xx.xx...."
#t = 10

WorkArry = [[]]

PebbleNum = [[0,0,0],[0,0,0],[0,0,0]]
GoalState = [[]]
MaxA = 0
MinB = 0
TopMINMAXScore = 0


horizontalPebbleNum = [[0,0,0],[0,0,0],[0,0,0]]
verticalPebbleNum = [[0,0,0],[0,0,0],[0,0,0]]
d1PebbleNum = [[0,0,0],[0,0,0],[0,0,0]]
d2PebbleNum = [[0,0,0],[0,0,0],[0,0,0]]

#is Input valid
    #ensure length of inputArry = n*n

def getArry(i):
    temparry=[]
    for j in range(i, i + n, 1):
        temparry.append(inputStr[j])
    return temparry

def convertTo2D():
    for i in range(0, len(inputStr), n):
        WorkArry.append(getArry(i))
    WorkArry.reverse()
    WorkArry.pop()
    WorkArry.reverse()

def printArry(Arr):
    for i in range(0, len(Arr)):
        if (i)%n != 0 or i==0:
            print Arr[i],            
        print "\n"

# Generate the states and check for the state with highest MINMAX score
#initialize current state with the workarry array start, consider next state as the goal state and verify
def setCurrentStateAsGoal():
    global GoalState
    GoalState = [[]]
    for i in range(0, n):
        GoalState.insert(i,WorkArry[i])
    GoalState.pop()
    #GoalState.reverse()
#initialize current state with the workarry array end

def findHorVerDiag_AnB(item, i, j):
    aVal = 0
    bVal = 0
    mmVal = 0

    bHorFlag = 0
    bVerFlag = 0
    diag1Flag = 0
    diag2Flag = 0

    countBhor = 0
    countBver = 0
    countDiag1 = 0
    countDiag2 = 0
    #horizontal
    for verIndex in range(0, n):
        if WorkArry[i][verIndex] == 'x':
            bHorFlag = 1 #we know that there is a pebble in the horizontal of this cell
            countBhor = countBhor + 1
#            PebbleNum[i][j] = PebbleNum[i][j] + 1

    #vertical
    for horIndex in range(0, n):
        if WorkArry[horIndex][j] == 'x':
            bVerFlag = 1 #we know that there is a pebble in the horizontal of this cell
            countBver = countBver + 1
 #           PebbleNum[i][j] = PebbleNum[i][j] + 1

    #diagonals    
    # we keep check of whether the cell falls in one of the two diagonals
    # If the cell is located in one of the digonals, then calculate the number of x in that diagonal
    flagIsInDiag1 = 0
    flagIsInDiag2 = 0

    #if i==j:
    #diagonal top left to bottom right
    for horIndex in range(0, n):
        for verIndex in range(0, n):
            if horIndex == verIndex:
                if horIndex == i and verIndex == j:
                    flagIsInDiag1 = 1

                if WorkArry[horIndex][verIndex] == 'x':
                    diag1Flag = 1;
                    countDiag1 = countDiag1 + 1
  #                  PebbleNum[i][j] = PebbleNum[i][j] + 1

    #diagonal top right to bottom left        
    for horIndex in range(n-1, -1, -1):
        for verIndex in range(0, n):
            if(horIndex + verIndex + 2 == n + 1):
                if horIndex == i and verIndex == j:
                    flagIsInDiag2 = 1

                if WorkArry[horIndex][verIndex] == 'x':
                    diag2Flag = 1
                    countDiag2 = countDiag2 + 1
   #                 PebbleNum[i][j] = PebbleNum[i][j] + 1

    #Calculate a and b based on the flags
    if bHorFlag == 0:
        aVal = aVal + 1
    else:
        bVal = bVal + 1

    if bVerFlag == 0:
        aVal = aVal + 1
    else:
        bVal = bVal + 1

    if flagIsInDiag1 == 1:
        if diag1Flag == 0:
            aVal = aVal + 1
        else:
            bVal = bVal + 1
    
    if flagIsInDiag2 == 1:
        if diag2Flag == 0:
            aVal = aVal + 1
        else:
            bVal = bVal + 1

    #find minmax value for this state
    mmVal = aVal - bVal 


    global TopMINMAXScore
    global MaxA
    global MinB
    
    
    if mmVal == 4:
        TopMINMAXScore = 4
        setCurrentStateAsGoal()
        MaxA = aVal
        MinB = bVal
        return 4

    #now compare it with the existing top score
    elif mmVal > TopMINMAXScore: #if higher, consider this as the probable goal state
        TopMINMAXScore = mmVal
        setCurrentStateAsGoal()
        MaxA = aVal
        MinB = bVal

    elif mmVal == TopMINMAXScore:
        if aVal > MaxA and bVal < MinB:
            setCurrentStateAsGoal()
    return mmVal

def assignValues():
    for i in range(0, n):
        for j in range(0, n):
            if WorkArry[i][j]!= 'x':
                retVal = findHorVerDiag_AnB(WorkArry[i][j], i, j)
                WorkArry[i][j] = str(retVal)
                if retVal == 4:  #4 can be the maximum possible number where a position does not have an intersecting X in horizontal and vertical and two diagonals
                    setCurrentStateAsGoal()
                    return
                elif retVal >= TopMINMAXScore:
                    setCurrentStateAsGoal()

def getFirstNumericVal():
    for i in range(0, n):
        for j in range(0, n):
            if(WorkArry[i][j]!='.' and WorkArry[i][j]!='x'):
                tempNum = int(WorkArry[i][j])
                return tempNum

def printGoal():
    print "New Board:"
    highIindex = 0
    highJindex = 0
    highestNumTillNow = getFirstNumericVal()
    printedX = 0

    #global GoalState
    if len(GoalState)>1:
        for i in range(0, n):
            for j in range(0, n):
                if(GoalState[i][j]!='.' and GoalState[i][j]!='x'):
                    tempNum = int(GoalState[i][j])
                    if tempNum == TopMINMAXScore and printedX == 0:
                        print 'X',
                        printedX = 1
                    else:
                        print '.',
                else:
                    print GoalState[i][j],
            #print ""
    else:
        for i in range(0, n):
            for j in range(0, n):
                if(WorkArry[i][j]!='.' and WorkArry[i][j]!='x'):
                    tempNum = int(WorkArry[i][j])
                    if tempNum >= highestNumTillNow:
                        highestNumTillNow = tempNum
                        highIindex = i
                        highJindex = j
        
        
        for i in range(0, n):
            for j in range(0, n):
                if(WorkArry[i][j]=='x'):
                    print 'x',
                else:
                    if i == highIindex and j == highJindex and printedX == 0:
                        print 'X',
                        printedX = 1
                    else:
                        print '.',
           # print ""
            
#start main task
if len(inputStr) == n*n:
    convertTo2D() # require to convert for easier constraint check
    #printArry(WorkArry) #verification

    print "Input:"
    print inputStr

#count the number of '.' in main array, based on that, create the number of states
    statesCount = 0
    for i in range(0, itemCount):
        if(inputStr[i] == '.'):
            statesCount = statesCount + 1

    for s in range(0, statesCount):
        #WorkArry = getNextState()
        assignValues()
    printGoal()

else:
    print "invalid input, please check the input and try again"